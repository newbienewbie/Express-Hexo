---
title: 数据结构与算法笔记 最短路径算法——Floyd算法
date: 2017-11-2 08:51:10
tags:
- 数据结构与算法
- 图论 
- 最短路径算法
- Floyd
categories:
- 大道
- 数据结构与算法
---

`Floyd-Warshall` 算法也称 Floyd's 算法，是用于求解任意点对之间最短路径的算法。叫这个奇怪的名字是因为`Robert Floyd`和`Stephen Warshal`这两人在同一年(1962年)各自独立提出了这个算法。`Floyd-Warshall`算法是典型的动态规划算法。

对于图`$G=(V,E)$`，各顶点之间弧`$<i,j>$`的权重表示为`$weight(i,j)$`，当两个顶点重合时(也就是`$i=j$`)，规定`$weight(i,j)=0$`；当两个顶点之间无弧连接时，规定`$weight(i,j)=\infty$`。对于稠密图，我们可以执行`$|V|$`次`Dijkstra`算法来获取任意点对的最短路径，但是对于稀疏图，采用结构更简单的`Floyd`算法更简单。

## Floyd's algorithm

在`Dijkstra`算法中我们指定始点为`$v_0$`，并将`$D_{v_0,k}(j)$`定义为从`$v_0$`到`$k$`只用到`$\{1,2,...,j\}$`的子集作为中间顶点的最短路径的值。现在我们把始点和终点扩展到任意点对：`$D_{p,q}(j)$`表示从始点`$p$`到终点`$p$`经过、或者不经过、但是最多只能经过集合`$\{1,2,...,j\}$`中顶点的最短路径值。
1. 显然，当不经过其他任何中间顶点，有`$D_{p,q}(0)=weight(p,q)$`
2. 当`$k>0$`，每次加入新的顶点`$k$`，最短路径必然只可能有两种情况：
    1. 是不经过其他任何中间节点的弧`$<p,q>$`，最短路径为`$D_{p,q}=weight(p,q)$`
    2. 是由路径`$p \rightarrow k$`和`$k \rightarrow q$` 合成的最短路径。即有`$D_{p,q}(k)=\displaystyle\min(D_{p,q}(k-1),   D_{p,k}(k-1)+D_{k,q}(k-1) )$`。

注意，递推关系表明：经过、或者不经过、但是最多只经过中间顶点集`$\{1,2,3,...,k\}$`(规模为`$k$`)的问题可以分解为规模为`$k-1$`的问题。根据这个关系，很容易设计出相应算法。 <!-- more -->

首先引入一个集合`$S$`，表示中间顶点集。我们将按照序号从小到达的顺序，依次把顶点`$i\in V$`加入到集合`$S$`中，然后计算加入顶点`$i$`之后的各点对最短路径。经过`$k$`次加入后，集合`$S=\{1,2,3,...,k\}$`，最终当`$V-S=\emptyset$`时算法结束。为了不失一般性，我们分析图的任意两个顶点`$v_p$`和`$v_q$`，并用`$D[p,q]$`来表示从顶点`$p$`到顶点`$q$`最短路径长度，为了计算`$D[p,q]$`，我们需要逐步递推。
1. 在初始状态下，如果二者有弧连接，则`$<v_p,v_q>$`可能是最短路径（相应的路径长可能为`$D[p,q]=weight(p,q)$`）。这里说“可能”，是因为两点之间直接相连的弧的权重不一定比分段连接的弧的权重之和要小。具体是不是，还需要在后续计算过程中加以甄别，如果后续计算过程发现了比之前计算的`$D[p,q]$`更小，则更新之。如果二者之间没有弧链接，我们暂时标记`$D[p,q]=\infty$`，留待后续处理。总而言之，我们在这一步令`$D[p,q]=weight(p,q)$`。
2. 根据递推关系，在每一步推算过程中，选择顶点`$k$`，准备加入到集合`$S$`，计算`$D[p,k]+D[k,q]$`，与之前的`$D[p,q]$`相比，取较小者作为新的最短路径。
3. 经过不停迭代，直至集合`$S$`包含了`$V$`中所有的顶点（也就是`$V-S=\emptyset$`）。

## 示例


例如，有图结构如下：
```
+---+                  2            +---+
|   +------------------------------->   |
| 0 |                               | 1 |
|   +----------------+              |   |
+-^-+       8        |              +-+-+
  |                  |                |
  |                +-v-+              |
  |                |   |       4      |
  |     5          | 2 <--------------+
  +----------------+   |
                   +---+
```

1. 设置初值：`$S=\{\}$`，`$A=\begin{bmatrix} 0 & 2 & 8 \\ \infty & 0 & 4 \\ 5 & \infty & 0 \end{bmatrix}$`
2. 加入`$k=0$`：`$S=\{0\}$`。`$A=\begin{bmatrix} 0 & 2 & 8 \\ \infty & 0 & 4 \\ 5 & \xcancel{\infty}\,7 & 0 \end{bmatrix}$`
3. 加入`$k=1$`：`$S=\{0,1\}$`。`$A=\begin{bmatrix} 0 & 2 & \xcancel{8}\,6 \\ \infty & 0 & 4 \\ 5 & 7 & 0 \end{bmatrix}$`
4. 加入`$k=2$`：`$S=\{0,1,2\}$`。`$A=\begin{bmatrix} 0 & 2 & 6 \\ \xcancel{\infty}\,9 & 0 & 4 \\ 5 & 7 & 0 \end{bmatrix}$`

## 算法实现

说起来很啰嗦，但是代码实现非常简单，去掉初始化代码，剩下的推算过程核心只有几行：
```c
// 逐步加入顶点k到集合S中
for(int k=0;k<n;k++){
    // 逐个比对A[i][j]
    for(int p=0;p<n;p++){
        for(int q=0;q<n;q++>){
            // 一旦发现更短的路径，就更新到A[p][q]中
            if(A[p][q]> A[p][k]+A[k][q]){ A[p][q]=A[p][k]+A[k][q]; }
        }
    }
}
```