---
title: 数据结构与算法笔记 最短路径算法——Floyd算法
date: 2017-11-2 08:51:10
tags:
- 数据结构与算法
- 图论 
- 最短路径算法
- Floyd
categories:
- 大道
- 数据结构与算法
---

`Floyd-Warshall` 算法也称 Floyd's 算法，是用于求解任意点对之间最短路径的算法。叫这个奇怪的名字是因为`Robert Floyd`和`Stephen Warshal`这两人在同一年(1962年)各自独立提出了这个算法。

对于图`$G=(V,E)$`，各顶点之间弧`$<i,j>$`的权重表示为`$weight(i,j)$`，当两个顶点重合时(也就是`$i=j$`)，规定`$weight(i,j)=0$`；当两个顶点之间无弧连接时，规定`$weight(i,j)=\infty$`。

## Floyd's algorithm

我们仍采取逐步计算的方式。<!-- more -->

首先引入一个集合`$S$`，表示我们逐步计算过程中已经被处理过的顶点，我们将按照序号从小到达的顺序，依次把顶点`$i\in V$`加入到集合`$S$`中，然后计算加入顶点`$i$`之后的各点对最短路径。经过`$k$`次加入后，集合`$S={1,2,3,...,k}$`，最终当`$V-S=\emptyset$`时算法结束。为了不失一般性，我们分析图的任意两个顶点`$v_i$`和`$v_j$`，并用`$A[i,j]$`来表示从顶点`$i$`到顶点`$j$`最短路径长度，为了计算`$A[i,j]$`，我们需要逐步递推。
1. 在初始状态下，如果二者有弧连接，则`$<v_i,v_j>$`可能是最短路径（相应的路径长可能为`$A[i,j]=weight(i,j)$`）。这里说“可能”，是因为两点之间直接相连的弧的权重不一定比分段连接的弧的权重之和要小。具体是不是，还需要在后续计算过程中加以甄别，如果后续计算过程发现了比之前计算的`$A[i,j]$`更小，则更新之。如果二者之间没有弧链接，我们暂时标记`$A[i,j]=\infty$`，留待后续处理。总而言之，我们在这一步令`$A[i,j]=weight(i,j)$`。
2. 上一步计算出了当两个顶点`$v_i$`和`$v_j$`之间不经过其他任意点时的最短路径。现在把顶点`$v_0$`加入集合`$S=\{\} \cup \{0\}=\{0\}$`，也就是要推算当`$v_i$`到`$v_j$`的路径可能经过、或者不经过`$v_0$`、但是最多只能经过`$S=\{0\}$`中的顶点时的最短路径。由于已经在上一步求出了不经过`$v_0$`时的最短路径，所以这里只要求必经过`$v_0$`时的最短路径即可。如果路径`$(v_i,v_0)$`和`$(v_0,v_j)$`都存在，则说明`$(v_i,v_0,v_j)$`可能是最短路径(长度`$A[i,0]+A[0,j]$`)，将其和上一步推算出来的长度`$A[i,j]$`相比，取较短者更新到`$A[i,j]$`中。
3. 之前一步推算出了顶点`$v_i$`到`$v_j$`可能经过、或者不经过集合、但是最多只能经过`$S=\{0\}$`中的顶点的情况。在此基础上，再把顶点`$v_1$`也加入集合`$S=\{0\} \cup \{1\}=\{0,1\}$`。由于已经算出了最多只能经过`$S$`中的顶点、但是不经过`$v_1$`时的最短路径，现在只需要推算必经过`$v_1$`时的路径是否最短即可——也即判断`$A[i,1]+A[1,j]$`是否比原来的`$A[i,j]$`路程更短。
4. 如此不停的推算，每一步加入新的顶点`$v_k$`到`$S$`，由于前一步已经求得了最多只能经过`$S$`集中的顶点、但是不经过`$v_k$`时的最短路径，这一步只需要推算必经过`$v_k$`时的最短路径即可。推算办法仍然是用`$A[i,j]$`和`$A[i,k]+A[k,j]$`比较然后取更距离更短者。
5. 经过不停迭代，直至集合`$S$`包含了`$V$`中所有的顶点（也就是`$V-S=\emptyset$`）。

## 示例


例如，有图结构如下：
```
+---+                  2            +---+
|   +------------------------------->   |
| 0 |                               | 1 |
|   +----------------+              |   |
+-^-+       8        |              +-+-+
  |                  |                |
  |                +-v-+              |
  |                |   |       4      |
  |     5          | 2 <--------------+
  +----------------+   |
                   +---+
```

1. 设置初值：`$S=\{\}$`，`$A=\begin{bmatrix} 0 & 2 & 8 \\ \infty & 0 & 4 \\ 5 & \infty & 0 \end{bmatrix}$`
2. 加入`$k=0$`：`$S=\{0\}$`。`$A=\begin{bmatrix} 0 & 2 & 8 \\ \infty & 0 & 4 \\ 5 & \xcancel{\infty}\,7 & 0 \end{bmatrix}$`
3. 加入`$k=1$`：`$S=\{0,1\}$`。`$A=\begin{bmatrix} 0 & 2 & \xcancel{8}\,6 \\ \infty & 0 & 4 \\ 5 & 7 & 0 \end{bmatrix}$`
4. 加入`$k=2$`：`$S=\{0,1,2\}$`。`$A=\begin{bmatrix} 0 & 2 & 6 \\ \xcancel{\infty}\,9 & 0 & 4 \\ 5 & 7 & 0 \end{bmatrix}$`

## 算法实现

说起来很啰嗦，但是代码实现非常简单，去掉初始化代码，剩下的推算过程核心只有几行：
```c
// 逐步加入顶点k到集合S中
for(int k=0;k<n;k++){
    // 逐个比对A[i][j]
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++>){
            // 一旦发现更短的路径，就更新到A[i][j]中
            if(A[i][j]> A[i][k]+A[k][j]){ A[i][j]=A[i][k]+A[k][j]; }
        }
    }
}
```