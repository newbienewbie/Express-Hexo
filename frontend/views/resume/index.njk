{% extends "../index.njk" %}
{% from "../_components/header/index.njk" import header %}
{% from "../_components/footer/index.njk" import footer %}


{% block userdefinedfoot %}
    {{super()}}
    <script type='text/javascript' src='//lib.baomitu.com/pixi.js/4.6.0/pixi.min.js'></script>
    <script type='text/javascript'>
        //Aliases
        const { Application,Container, Texture, Sprite, Text, Graphics } = PIXI;
        const TextureCache = PIXI.utils.TextureCache;
        const EventEmitter= PIXI.utils.EventEmitter;
        const AnimatedSprite=PIXI.extras.AnimatedSprite;

        const app=new PIXI.Application(512,512);
        document.body.appendChild(app.view);
        app.stop();


        class GameScene extends EventEmitter{
            constructor(){
                super();
                this.scene=new Container();
                // sprites dict 
                this.sprites={};
            }
            setup(stage){
                stage.addChild(this.scene);
            }

            run(){
                throw Error('the #run() method must be implemented by subclass');
            }
        }

        class EndingGameScene extends GameScene{
            constructor(){
                super();
                this.on('won',()=>{
                    this.sprites['message'].text='You Won !';
                    this.scene.visible=true;
                });
                this.on('lost',()=>{
                    this.scene.visible=true;
                    this.sprites['message'].text='You Lost !';
                });
            }
            setup(stage){
                this.scene.visible = false;
                const message = new Text( "The End!", { font: "64px Futura", fill: "white" });
                message.x = 120;
                message.y = stage.height / 2 - 32;
                this.sprites['message']=message;
                this.scene.addChild(message);
                super.setup(stage);
            }
            run(){
            }
        }

        class PlayingGameScene extends GameScene{
            constructor(){
                super();
                this.blobs=[];
            }

            setup(stage){
                super.setup(stage);

                //Make the sprites and add them to the `this.scene`
                //Create an alias for the texture atlas frame ids
                const textures = app.loader.resources["treasureHunter"].textures;

                //Dungeon
                this.sprites["dungeon"] = new Sprite(textures["dungeon.png"]);
                this.scene.addChild(this.sprites["dungeon"]);

                //Door
                this.sprites["door"] = new Sprite(textures["door.png"]);
                this.sprites["door"].position.set(32, 0);
                this.scene.addChild(this.sprites["door"]);

                //Explorer
                const explorer=this.sprites["explorer"] = createExplorer(textures["explorer.png"]);
                explorer.position.set(68,this.scene.height / 2 - explorer.height / 2 );
                this.scene.addChild(this.sprites["explorer"]);

                //Treasure
                const treasure=this.sprites["treasure"] = new Sprite(textures["treasure.png"]);
                treasure.position.set(
                    this.scene.width - treasure.width - 48,
                    this.scene.height / 2 - treasure.height / 2
                );
                this.scene.addChild(this.sprites["treasure"]);

                //Make the blobs
                const numberOfBlobs = 6;
                const spacing = 48;
                const xOffset = 150;
                let direction = 1;
                const speed = 5;

                //An array to store all the blob monsters
                const blobs = [];
                this.blobs=blobs;

                //Make as many blobs as there are `numberOfBlobs`
                let blobTexture = textures['blob.png'];
                for (var i = 0; i < numberOfBlobs; i++) {

                    //Make a blob
                    var blob = createBlob(blobTexture, {
                        speed,
                        direction
                    });

                    //Space each blob horizontally according to the `spacing` value.
                    //`xOffset` determines the point from the left of the screen
                    //at which the first blob should be added
                    var x = spacing * i + xOffset;

                    //Give the blob a random y position
                    var y = randomInt(0, stage.height - blob.height);

                    //Set the blob's position
                    blob.x = x;
                    blob.y = y;

                    //Reverse the direction for the next blob
                    direction *= -1;

                    //Push the blob into the `blobs` array
                    blobs.push(blob);

                    //Add the blob to the `this.scene`
                    this.scene.addChild(blob);
                }

                //Create the health bar
                const healthBar=this.sprites["healthBar"] = createHealthBar();
                healthBar.position.set(stage.width - 170, 6)
                this.scene.addChild(healthBar);

                bindKeyStrokeToPlayer(explorer);
            }

            run(){
                const explorer=this.sprites['explorer'];
                const treasure=this.sprites['treasure'];
                const healthBar=this.sprites['healthBar'];
                const door=this.sprites['door'];
                const blobs=this.blobs;

                //use the explorer's velocity to make it move
                explorer.x += explorer.vx;
                explorer.y += explorer.vy;

                //Contain the explorer inside the area of the dungeon
                contain(explorer, { x: 28, y: 10, width: 488, height: 480 });
                //contain(explorer, stage);

                //Set `explorerHit` to `false` before checking for a collision
                var explorerHit = false;

                //Loop through all the sprites in the `enemies` array
                blobs.forEach(function (blob) {

                    //Move the blob
                    blob.y += blob.vy;

                    //Check the blob's screen boundaries
                    var blobHitsWall = contain(blob, { x: 28, y: 10, width: 488, height: 480 });

                    //If the blob hits the top or bottom of the stage, reverse
                    //its direction
                    if (blobHitsWall === "top" || blobHitsWall === "bottom") {
                        // blob.vy *= -1;
                        blob.emit('hit_boundry');
                    }

                    //Test for a collision. If any of the enemies are touching
                    //the explorer, set `explorerHit` to `true`
                    if (hitTestRectangle(explorer, blob)) {
                        explorerHit = true;
                    }
                });

                //If the explorer is hit...
                if (explorerHit) {

                    //Make the explorer semi-transparent
                    explorer.alpha = 0.5;

                    //Reduce the width of the health bar's inner rectangle by 1 pixel
                    // healthBar.outer.width -= 1;
                    healthBar.emit(`get_hurt`, 1);
                    const explosion=createExplosion();
                    let point=app.stage.toGlobal(explorer.position);
                    explosion.position.set(point.x- explosion.width/2,point.y - explosion.height/2);
                    app.stage.addChild(explosion);
                    explosion.play();

                } else {
                    //Make the explorer fully opaque (non-transparent) if it hasn't been hit
                    explorer.alpha = 1;
                }

                //Check for a collision between the explorer and the treasure
                if (hitTestRectangle(explorer, treasure)) {

                    //If the treasure is touching the explorer, center it over the explorer
                    treasure.x = explorer.x + 8;
                    treasure.y = explorer.y + 8;
                }

                //Does the explorer have enough health? If the width of the `innerBar`
                //is less than zero, end the game and display "You lost!"
                if (healthBar.outer.width < 0) {
                    //state = end;
                    //message.text = "You lost!";
                    this.emit('lost');
                }

                //If the explorer has brought the treasure to the exit,
                //end the game and display "You won!"
                if (hitTestRectangle(treasure, door)) {
                    //state = end;
                    //message.text = "You won!";
                    this.emit('won');
                }
            }
        }


        app.loader
            .add('treasureHunter',"/static/img/treasureHunter.json")
            .add('explosion','/static/img/explosion.json')
            .load(setup);


        /**
         *  当前的游戏场景状态
         */
        let state;
        app.ticker.add(function(delta){
            state();
        });





        function setup() {

            const stage=app.stage;
            //Make the game scene and add it to the stage

            const playingScene=new PlayingGameScene();
            playingScene.setup(stage);

            const endingScene=new EndingGameScene();
            endingScene.setup(stage);

            playingScene.on('won',function(){
                endingScene.emit('won');
                this.scene.visible=false;
                state=endingScene.run.bind(endingScene);
            });
            playingScene.on('lost',function(){
                endingScene.emit('lost');
                this.scene.visible=false;
                state=endingScene.run.bind(endingScene);
            });

            //Set the game state
            state = playingScene.run.bind(playingScene);

            app.start();
        }


        function bindKeyStrokeToPlayer(explorer){
            //Capture the keyboard arrow keys
            var left = keyboard(37),
                up = keyboard(38),
                right = keyboard(39),
                down = keyboard(40);

            //Left arrow key `press` method
            left.press = function () {
                explorer.emit('move_left');
            };
            left.release = function () {
                if (!right.isDown && explorer.vy === 0) {
                    explorer.emit('stop_left');
                }
            };

            //Up
            up.press = function () { 
                explorer.emit('move_top'); 
            };
            up.release = function () {
                if (!down.isDown && explorer.vx === 0) {
                    explorer.emit('stop_top');
                }
            };

            //Right
            right.press = function () {
                explorer.emit('move_right');
            };
            right.release = function () {
                if (!left.isDown && explorer.vy === 0) {
                    explorer.emit('stop_right');
                }
            };

            //Down
            down.press = function () {
                explorer.emit('move_bottom');
            };
            down.release = function () {
                if (!up.isDown && explorer.vx === 0) {
                    explorer.emit('stop_bottom');
                }
            };
        }

        function createExplosion(){
            const textures=[];
            for(let i=0;i<26;i++){
                let name=`Explosion_Sequence_A ${i+1}.png`;
                let texture=Texture.fromFrame(name);
                textures.push(texture);
            }
            const explosion=new AnimatedSprite(textures);
            explosion.loop=false;
            explosion.scale.set(0.5,0.5);
            explosion.onComplete=function(){
                this.destroy();
            };
            return explosion;
        }

        function createHealthBar() {
            const healthBar = new Container();

            //Create the black background rectangle
            const innerBar = new Graphics();
            innerBar.beginFill(0x000000);
            innerBar.drawRect(0, 0, 100, 8);
            innerBar.endFill();
            healthBar.addChild(innerBar);

            //Create the front red rectangle
            const outerBar = new Graphics();
            outerBar.beginFill(0xFF0000);
            outerBar.drawRect(0, 0, 100, 8);
            outerBar.endFill();
            healthBar.addChild(outerBar);

            healthBar.outer = outerBar;

            healthBar.on('get_hurt', function (damage) {
                this.outer.width -= damage;
            });
            return healthBar;
        }

        function createExplorer(texture, opts) {
            const explorer = new Sprite(texture);
            const speed=2;
            explorer.vx = 0;
            explorer.vy = 0;

            explorer.on('move_left',function(){
                this.vx = -speed;
                this.vy = 0;
            });
            explorer.on('stop_left',function(){
                this.vx = 0;
            });
            explorer.on('move_right',function(){
                this.vx = speed;
                this.vy = 0;
            });
            explorer.on('stop_right',function(){
                this.vx = 0;
            });
            explorer.on('move_top',function(){
                this.vx = 0;
                this.vy = -speed;
            });
            explorer.on('stop_top',function(){
                this.vy = 0;
            });
            explorer.on('move_bottom',function(){
                this.vx = 0;
                this.vy = speed;
            });
            explorer.on('stop_bottom',function(){
                this.vy = 0;
            });

            return explorer;
        }

        function createBlob(texture, opts = { speed: 0, direction: 1 }) {

            const { speed, direction } = opts;
            //Make a blob
            const blob = new Sprite(texture);

            blob.speed = speed;
            blob.direction = direction;
            //Set the blob's vertical velocity. `direction` will be either `1` or
            //`-1`. `1` means the enemy will move down and `-1` means the blob will
            //move up. Multiplying `direction` by `speed` determines the blob's
            //vertical direction
            blob.vy = speed * direction;
            blob.on('hit_boundry', function () {
                this.vy = -this.vy;
                this.direction = -this.direction;
            });
            return blob;
        }


        /* Helper functions */
        function contain(sprite, container) {

            var collision = undefined;

            //Left
            if (sprite.x < container.x) {
                sprite.x = container.x;
                collision = "left";
            }

            //Top
            if (sprite.y < container.y) {
                sprite.y = container.y;
                collision = "top";
            }

            //Right
            if (sprite.x + sprite.width > container.width) {
                sprite.x = container.width - sprite.width;
                collision = "right";
            }

            //Bottom
            if (sprite.y + sprite.height > container.height) {
                sprite.y = container.height - sprite.height;
                collision = "bottom";
            }

            //Return the `collision` value
            return collision;
        }

        //The `hitTestRectangle` function
        function hitTestRectangle(r1, r2) {

            //Define the variables we'll need to calculate
            var hit, combinedHalfWidths, combinedHalfHeights, vx, vy;

            //hit will determine whether there's a collision
            hit = false;

            //Find the center points of each sprite
            r1.centerX = r1.x + r1.width / 2;
            r1.centerY = r1.y + r1.height / 2;
            r2.centerX = r2.x + r2.width / 2;
            r2.centerY = r2.y + r2.height / 2;

            //Find the half-widths and half-heights of each sprite
            r1.halfWidth = r1.width / 2;
            r1.halfHeight = r1.height / 2;
            r2.halfWidth = r2.width / 2;
            r2.halfHeight = r2.height / 2;

            //Calculate the distance vector between the sprites
            vx = r1.centerX - r2.centerX;
            vy = r1.centerY - r2.centerY;

            //Figure out the combined half-widths and half-heights
            combinedHalfWidths = r1.halfWidth + r2.halfWidth;
            combinedHalfHeights = r1.halfHeight + r2.halfHeight;

            //Check for a collision on the x axis
            if (Math.abs(vx) < combinedHalfWidths) {

                //A collision might be occuring. Check for a collision on the y axis
                if (Math.abs(vy) < combinedHalfHeights) {

                    //There's definitely a collision happening
                    hit = true;
                } else {

                    //There's no collision on the y axis
                    hit = false;
                }
            } else {

                //There's no collision on the x axis
                hit = false;
            }

            //`hit` will be either `true` or `false`
            return hit;
        };


        //The `randomInt` helper function
        function randomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        //The `keyboard` helper function
        function keyboard(keyCode) {
            var key = {};
            key.code = keyCode;
            key.isDown = false;
            key.isUp = true;
            key.press = undefined;
            key.release = undefined;
            //The `downHandler`
            key.downHandler = function (event) {
                if (event.keyCode === key.code) {
                    if (key.isUp && key.press) key.press();
                    key.isDown = true;
                    key.isUp = false;
                }
                event.preventDefault();
            };

            //The `upHandler`
            key.upHandler = function (event) {
                if (event.keyCode === key.code) {
                    if (key.isDown && key.release) key.release();
                    key.isDown = false;
                    key.isUp = true;
                }
                event.preventDefault();
            };

            //Attach event listeners
            window.addEventListener(
                "keydown", key.downHandler.bind(key), false
            );
            window.addEventListener(
                "keyup", key.upHandler.bind(key), false
            );
            return key;
        }
    </script>
{% endblock %}